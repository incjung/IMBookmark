안녕하세요! 구글 확장 프로그램을 통해 북마크를 효과적으로 관리하고 싶으시군요. 요청하신 기능에 맞춰, URL의 콘텐츠에서 키워드를 추출하고 이를 통해 검색 및 관리하는 확장 프로그램의 전체 구현 코드를 단계별로 안내해 드리겠습니다.

LLM(거대 언어 모델)을 직접 확장 프로그램에 내장하기에는 용량 및 비용 문제가 있으므로, 초기 버전에서는 웹 페이지의 핵심 텍스트(제목, 메타 태그, 주요 제목 등)를 분석하여 키워드를 추출하는 방식으로 구현합니다. 이 방식은 LLM 없이도 충분히 효과적인 검색을 가능하게 합니다.

프로젝트 구조

확장 프로그램은 다음과 같은 파일들로 구성됩니다.

Generated code
/bookmark-search-extension
|-- manifest.json
|-- background.js
|-- popup.html
|-- popup.css
|-- popup.js
|-- icons/
|   |-- icon16.png
|   |-- icon48.png
|   |-- icon128.png


(아이콘 파일은 직접 준비하셔야 하며, 예시에서는 경로만 지정합니다.)

1. manifest.json 파일 작성

이 파일은 확장 프로그램의 기본 설정과 권한을 정의하는 가장 중요한 파일입니다.

Generated json
{
  "manifest_version": 3,
  "name": "콘텐츠 기반 북마크 검색기",
  "version": "1.0",
  "description": "북마크된 페이지의 콘텐츠를 기반으로 키워드를 추출하고 검색하는 확장 프로그램입니다.",
  "permissions": [
    "bookmarks",
    "storage",
    "tabs",
    "scripting"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

주요 설정 설명:

"permissions":

bookmarks: 북마크를 읽어오기 위한 권한

storage: 키워드 데이터를 저장하기 위한 권한

tabs: 선택한 북마크를 새 탭에서 열기 위한 권한

scripting: 웹 페이지 콘텐츠에 접근하기 위한 권한

"host_permissions": 모든 URL(<all_urls>)에 접근하여 콘텐츠를 가져올 수 있도록 허용합니다.

"background": 백그라운드에서 북마크 처리 및 키워드 추출을 담당할 스크립트를 지정합니다.

"action": 사용자가 클릭할 툴바 아이콘과 팝업 창을 정의합니다.

2. background.js (백그라운드 스크립트)

이 스크립트는 확장 프로그램의 핵심 로직을 담당합니다. 북마크를 읽고, 각 URL의 콘텐츠를 분석해 키워드를 추출하며, 이를 로컬 스토리지에 저장합니다.

Generated javascript
// 자주 사용되는 단어(불용어) 목록. 키워드 추출 시 제외됩니다.
const STOP_WORDS = new Set(['a', 'about', 'above', ...'and', 'the', 'in', 'is', 'it', 'of', 'on', 'for', 'with']);

// 확장 프로그램이 처음 설치되거나 업데이트될 때 실행됩니다.
chrome.runtime.onInstalled.addListener(() => {
  console.log('북마크 키워드 추출 확장 프로그램이 설치되었습니다.');
  processAllBookmarks();
});

// 북마크가 생성될 때 해당 북마크만 처리합니다.
chrome.bookmarks.onCreated.addListener((id, bookmark) => {
  if (bookmark.url) {
    processSingleBookmark(bookmark);
  }
});

// 모든 북마크를 가져와 처리하는 함수
async function processAllBookmarks() {
  console.log('모든 북마크 처리를 시작합니다...');
  const bookmarkTreeNodes = await chrome.bookmarks.getTree();
  const bookmarks = flattenBookmarkTree(bookmarkTreeNodes);
  
  const processedData = {};

  for (const bookmark of bookmarks) {
    if (bookmark.url) {
      const keywords = await extractKeywords(bookmark.url);
      processedData[bookmark.url] = {
        title: bookmark.title,
        keywords: keywords
      };
    }
  }

  await chrome.storage.local.set({ bookmarks: processedData });
  console.log('모든 북마크 처리가 완료되어 스토리지에 저장되었습니다.');
}

// 단일 북마크를 처리하고 스토리지에 추가/업데이트하는 함수
async function processSingleBookmark(bookmark) {
    const { bookmarks } = await chrome.storage.local.get('bookmarks');
    const existingData = bookmarks || {};

    const keywords = await extractKeywords(bookmark.url);
    existingData[bookmark.url] = {
        title: bookmark.title,
        keywords: keywords
    };

    await chrome.storage.local.set({ bookmarks: existingData });
    console.log(`북마크 [${bookmark.title}] 처리가 완료되었습니다.`);
}


// 북마크 트리를 평탄화하여 URL 목록으로 만드는 함수
function flattenBookmarkTree(bookmarkTreeNodes) {
  const bookmarks = [];
  const stack = [...bookmarkTreeNodes];
  while (stack.length > 0) {
    const node = stack.pop();
    if (node.url) {
      bookmarks.push({ title: node.title, url: node.url });
    }
    if (node.children) {
      stack.push(...node.children);
    }
  }
  return bookmarks;
}

// URL에 접속하여 키워드를 추출하는 함수
async function extractKeywords(url) {
  try {
    const response = await fetch(url, { signal: AbortSignal.timeout(10000) }); // 10초 타임아웃
    const contentType = response.headers.get('content-type');

    // HTML 페이지인 경우에만 텍스트를 분석합니다.
    if (contentType && contentType.includes('text/html')) {
      const html = await response.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      
      const title = doc.querySelector('title')?.innerText || '';
      const description = doc.querySelector('meta[name="description"]')?.content || '';
      const h1 = Array.from(doc.querySelectorAll('h1')).map(h => h.innerText).join(' ');

      const textContent = `${title} ${description} ${h1}`;
      
      // 단어로 분리하고, 불용어 제거, 중복 제거
      const words = textContent.toLowerCase().match(/\b(\w+)\b/g) || [];
      const uniqueKeywords = [...new Set(words.filter(word => word.length > 2 && !STOP_WORDS.has(word)))];
      
      return uniqueKeywords.slice(0, 10); // 최대 10개의 키워드만 저장
    } else {
      // PDF, 이미지 등의 경우 파일 타입을 키워드로 저장합니다.
      const type = contentType ? contentType.split('/')[1].split(';')[0].toUpperCase() : 'ETC';
      return [type];
    }
  } catch (error) {
    console.error(`URL [${url}] 처리 중 오류 발생:`, error);
    return ['오류']; // 접속 실패 시 '오류' 키워드 부여
  }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END
3. popup.html (팝업 UI)

사용자가 확장 프로그램 아이콘을 클릭했을 때 보게 될 화면의 구조입니다.

Generated html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>북마크 검색</title>
    <link rel="stylesheet" href="popup.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <input type="text" id="searchInput" placeholder="키워드 또는 제목으로 검색...">
            <button id="refreshButton" title="북마크 데이터 새로고침">🔄</button>
        </div>
        <div class="results-header">
            <div>
                <input type="checkbox" id="selectAllCheckbox">
                <label for="selectAllCheckbox">전체 선택</label>
            </div>
            <span id="resultCount">결과: 0개</span>
        </div>
        <ul id="resultsList"></ul>
        <button id="openSelectedButton">선택한 북마크 열기</button>
    </div>
    <script src="popup.js"></script>
</body>
</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END
4. popup.css (팝업 스타일)

팝업 창의 디자인을 담당합니다.

Generated css
body {
    font-family: sans-serif;
    width: 400px;
    background-color: #f4f4f9;
}

.container {
    padding: 10px;
}

.header {
    display: flex;
    margin-bottom: 10px;
}

#searchInput {
    flex-grow: 1;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#refreshButton {
    margin-left: 5px;
    padding: 8px 10px;
    border: none;
    background: #e0e0e0;
    cursor: pointer;
    border-radius: 4px;
}

.results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #555;
    margin-bottom: 5px;
}

#resultsList {
    list-style-type: none;
    padding: 0;
    margin: 0;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #ddd;
    background-color: white;
}

#resultsList li {
    padding: 8px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
}

#resultsList li:last-child {
    border-bottom: none;
}

#resultsList input[type="checkbox"] {
    margin-right: 10px;
}

#resultsList .content {
    display: flex;
    flex-direction: column;
}

#resultsList .title {
    font-weight: bold;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 320px;
}

#resultsList .keywords {
    font-size: 11px;
    color: #777;
}

#openSelectedButton {
    width: 100%;
    padding: 10px;
    margin-top: 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
}

#openSelectedButton:hover {
    background-color: #45a049;
}```

---

### 5. `popup.js` (팝업 스크립트)

팝업 내의 모든 상호작용(검색, 선택, 탭 열기 등)을 처리합니다.

```javascript
document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('searchInput');
    const resultsList = document.getElementById('resultsList');
    const resultCount = document.getElementById('resultCount');
    const openSelectedButton = document.getElementById('openSelectedButton');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    const refreshButton = document.getElementById('refreshButton');

    let allBookmarks = {};

    // 스토리지에서 북마크 데이터를 로드하고 화면에 표시
    async function loadAndDisplayBookmarks() {
        const data = await chrome.storage.local.get('bookmarks');
        allBookmarks = data.bookmarks || {};
        filterAndRender(''); // 처음에는 모든 북마크 표시
    }

    // 검색어에 따라 북마크를 필터링하고 렌더링
    function filterAndRender(query) {
        resultsList.innerHTML = '';
        const lowerCaseQuery = query.toLowerCase();
        let count = 0;

        const filteredUrls = Object.keys(allBookmarks).filter(url => {
            const bookmark = allBookmarks[url];
            const titleMatch = bookmark.title.toLowerCase().includes(lowerCaseQuery);
            const keywordMatch = bookmark.keywords.some(k => k.toLowerCase().includes(lowerCaseQuery));
            return titleMatch || keywordMatch;
        });
        
        count = filteredUrls.length;

        filteredUrls.forEach(url => {
            const bookmark = allBookmarks[url];
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <input type="checkbox" data-url="${url}">
                <div class="content">
                    <span class="title" title="${bookmark.title}">${bookmark.title}</span>
                    <span class="keywords">키워드: ${bookmark.keywords.join(', ')}</span>
                </div>
            `;
            resultsList.appendChild(listItem);
        });

        resultCount.textContent = `결과: ${count}개`;
        updateOpenButtonState();
    }

    // 선택된 북마크 열기 버튼 상태 업데이트
    function updateOpenButtonState() {
        const selectedCount = resultsList.querySelectorAll('input[type="checkbox"]:checked').length;
        openSelectedButton.disabled = selectedCount === 0;
        openSelectedButton.textContent = selectedCount > 0 ? `${selectedCount}개 북마크 열기` : '선택한 북마크 열기';
    }

    // 검색 입력 이벤트 리스너
    searchInput.addEventListener('input', () => {
        filterAndRender(searchInput.value);
        selectAllCheckbox.checked = false;
    });

    // 결과 목록 클릭 이벤트 (체크박스 상태 업데이트)
    resultsList.addEventListener('change', () => {
        updateOpenButtonState();
        const allCheckboxes = resultsList.querySelectorAll('input[type="checkbox"]');
        const checkedCount = resultsList.querySelectorAll('input[type="checkbox"]:checked').length;
        selectAllCheckbox.checked = allCheckboxes.length > 0 && checkedCount === allCheckboxes.length;
    });

    // 전체 선택 체크박스 이벤트 리스너
    selectAllCheckbox.addEventListener('change', () => {
        const isChecked = selectAllCheckbox.checked;
        resultsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.checked = isChecked;
        });
        updateOpenButtonState();
    });

    // 선택한 북마크 열기 버튼 클릭 이벤트
    openSelectedButton.addEventListener('click', () => {
        const selectedCheckboxes = resultsList.querySelectorAll('input[type="checkbox"]:checked');
        selectedCheckboxes.forEach(checkbox => {
            const url = checkbox.getAttribute('data-url');
            if (url) {
                chrome.tabs.create({ url: url });
            }
        });
    });

    // 새로고침 버튼 클릭 이벤트
    refreshButton.addEventListener('click', () => {
        alert('북마크 데이터 새로고침을 시작합니다. 완료되면 알림이 표시됩니다. (백그라운드 스크립트 콘솔 확인)');
        // 백그라운드 스크립트에 메시지를 보내 전체 처리를 다시 실행하도록 요청할 수 있습니다.
        // 여기서는 간단하게 background.js의 processAllBookmarks 함수를 직접 호출하는 방식 대신,
        // 사용자에게 새로고침이 시작되었음을 알립니다. 실제 구현에서는 메시징 API를 사용할 수 있습니다.
        chrome.runtime.getBackgroundPage(backgroundPage => {
            backgroundPage.processAllBookmarks();
        });
    });

    // 초기 로드
    loadAndDisplayBookmarks();
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Css
IGNORE_WHEN_COPYING_END
6. 설치 및 사용 방법

위 코드들을 각각의 파일 이름으로 저장합니다. icons 폴더를 만들고 16x16, 48x48, 128x128 픽셀 크기의 PNG 아이콘 파일을 넣어주세요. (아이콘이 없으면 오류가 발생할 수 있습니다.)

Chrome 브라우저를 열고 주소창에 chrome://extensions를 입력합니다.

오른쪽 상단의 '개발자 모드'를 활성화합니다.

'압축해제된 확장 프로그램을 로드합니다' 버튼을 클릭합니다.

프로젝트 폴더(bookmark-search-extension)를 선택합니다.

설치가 완료되면 브라우저 툴바에 새로운 아이콘이 생깁니다.

초기 실행: 확장 프로그램이 처음 설치되면 background.js가 자동으로 모든 북마크를 읽고 처리하기 시작합니다. 북마크가 많을 경우 몇 분 정도 소요될 수 있습니다. chrome://extensions 페이지에서 해당 확장 프로그램의 '서비스 워커' 링크를 클릭하여 콘솔 로그를 통해 진행 상황을 확인할 수 있습니다.

7. 한계 및 향후 개선 방안

LLM 미적용: 현재 구현은 정해진 규칙에 따라 키워드를 추출합니다. 더 높은 수준의 문맥 이해를 위해서는 외부 LLM API(예: OpenAI, Google AI)를 연동하고, 사용자가 자신의 API 키를 옵션 페이지에 입력하여 사용하도록 개선할 수 있습니다.

동적 페이지 처리: JavaScript로 콘텐츠가 렌더링되는 동적인 웹사이트의 경우, fetch만으로는 완벽한 콘텐츠를 가져오기 어렵습니다. chrome.scripting.executeScript를 사용하여 페이지에 직접 스크립트를 주입하고, 렌더링된 후의 DOM에서 텍스트를 추출하는 방식으로 정확도를 높일 수 있습니다.

새로고침: 현재 새로고침 기능은 백그라운드 프로세스를 직접 트리거하지만, 더 안정적인 방법은 chrome.runtime.sendMessage를 사용하여 백그라운드 스크립트에 작업을 요청하는 것입니다.
=====

롬 주소창(Omnibox)에서 myurl: 키워드를 사용해 북마크를 검색하는 기능을 추가해 보겠습니다.
이 기능을 구현하기 위해서는 manifest.json 파일에 omnibox 설정을 추가하고, background.js 파일에 Omnibox 관련 이벤트 리스너를 등록해야 합니다.
popup.html, popup.css, popup.js 파일은 이전 단계와 동일하며 수정할 필요가 없습니다.



=======

따로 데이터를 관리
========

네, 아주 좋은 지적이십니다. 추출된 키워드와 북마크 메타데이터를 크롬의 기본 북마크 시스템과 완전히 분리하여 독립적으로 관리하는 것은 확장 프로그램의 안정성과 확장성을 위해 매우 중요한 설계입니다.

현재 제공해 드린 코드가 바로 그 방식으로 동작하고 있습니다.

사용자님의 요구사항을 다시 한번 명확히 짚어보고, 코드의 어떤 부분이 그 역할을 하는지, 그리고 이 방식이 어떤 장점을 갖는지 설명해 드리겠습니다.

분리된 데이터 관리 방식 설명

요청하신 "별도 관리"의 핵심은, 크롬 북마크를 **원본 데이터(Source of Truth)**로 사용하되, 우리가 가공한 키워드 데이터는 확장 프로그램만의 독립적인 데이터베이스에 저장하는 것입니다.

이 확장 프로그램에서는 chrome.storage.local을 그 독립적인 데이터베이스로 사용합니다.

데이터 흐름:

읽기 (Read): background.js가 chrome.bookmarks.getTree() API를 사용하여 크롬에 저장된 모든 북마크의 제목(title)과 URL을 읽어오기만 합니다. 원본 북마크는 절대 수정하지 않습니다.

처리 (Process): 읽어온 각 URL에 접속하여 콘텐츠를 분석하고, 키워드를 추출합니다.

저장 (Store): 원본 북마크 정보(title, url)와 새롭게 추출된 키워드(keywords)를 하나의 객체로 묶어 chrome.storage.local이라는 확장 프로그램 전용 저장소에 저장합니다.

이후 팝업 UI(popup.js)나 주소창 검색(background.js의 omnibox 리스너)은 오직 chrome.storage.local에 저장된 이 가공된 데이터만을 사용하여 검색 및 표시 기능을 수행합니다.

코드에서 분리된 관리를 확인하기

1. background.js - 데이터 생성 및 저장

Generated javascript
// ... (생략) ...

// 모든 북마크를 가져와 처리하는 함수
async function processAllBookmarks() {
  console.log('모든 북마크 처리를 시작합니다...');
  // 1. 크롬 북마크를 '읽기 전용'으로 가져옴
  const bookmarkTreeNodes = await chrome.bookmarks.getTree();
  const bookmarks = flattenBookmarkTree(bookmarkTreeNodes);
  
  // 2. 우리만의 데이터 구조를 만듦
  const processedData = {};

  for (const bookmark of bookmarks) {
    if (bookmark.url && (bookmark.url.startsWith('http:') || bookmark.url.startsWith('https:'))) {
      const keywords = await extractKeywords(bookmark.url);
      // 3. { url: { title, keywords } } 형태로 가공
      processedData[bookmark.url] = {
        title: bookmark.title,
        keywords: keywords
      };
    }
  }

  // 4. 'chrome.storage.local'이라는 별도 공간에 저장
  await chrome.storage.local.set({ bookmarks: processedData });
  console.log('모든 북마크 처리가 완료되어 스토리지에 저장되었습니다.');
}


여기서 chrome.bookmarks는 데이터를 가져오는 데만 사용되고, 저장하는 곳은 chrome.storage.local임을 명확히 알 수 있습니다.

2. popup.js 및 Omnibox - 데이터 사용

팝업 창과 주소창 검색 기능은 데이터를 조회할 때 chrome.bookmarks API를 전혀 사용하지 않습니다.

Generated javascript
// popup.js 의 일부
async function loadAndDisplayBookmarks() {
    // 오직 chrome.storage.local에서만 데이터를 가져옴
    const data = await chrome.storage.local.get('bookmarks');
    allBookmarks = data.bookmarks || {};
    filterAndRender('');
}

// background.js 의 omnibox 리스너 일부
chrome.omnibox.onInputChanged.addListener(async (text, suggest) => {
    // 여기도 chrome.storage.local에서만 데이터를 가져옴
    const { bookmarks } = await chrome.storage.local.get('bookmarks');
    // ... (이후 로직)
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END
이 방식의 장점

원본 데이터 보호: 사용자의 소중한 원본 북마크를 절대 건드리지 않으므로 안전합니다. 키워드를 제목에 추가하는 등의 지저분한 작업을 하지 않습니다.

독자적인 데이터 구조: title, keywords 외에도 나중에 last_visited_date, click_count 등 확장 프로그램에 필요한 어떤 정보든 자유롭게 추가하여 관리할 수 있습니다.

성능: 검색에 최적화된 형태로 데이터를 저장하므로, 매번 크롬 북마크 트리를 탐색할 필요 없이 빠르고 효율적인 검색이 가능합니다.

오프라인 작동: 한번 키워드 데이터가 chrome.storage.local에 저장되면, 인터넷 연결 없이도 저장된 키워드로 북마크를 검색할 수 있습니다. (물론 페이지를 여는 것은 인터넷이 필요합니다.)

동기화 문제 및 해결 (중요)

별도로 데이터를 관리할 때 발생하는 유일한 문제는 동기화입니다. 만약 사용자가 크롬에서 북마크를 삭제하면, 우리의 chrome.storage.local에는 여전히 그 북마크의 정보가 남아있게 됩니다 (이를 'stale data'라고 합니다).

이 문제를 해결하기 위해, 북마크 삭제 이벤트를 감지하고 우리 저장소에서도 해당 데이터를 지워주는 로직을 추가하는 것이 좋습니다.

background.js 파일에 다음 코드를 추가하여 이 문제를 해결할 수 있습니다.

Generated javascript
// background.js 파일의 맨 아래에 추가하세요.

// ==========================================================
// 북마크 삭제 시 로컬 스토리지와 동기화
// ==========================================================
chrome.bookmarks.onRemoved.addListener(async (id, removeInfo) => {
    // 삭제된 북마크의 URL을 직접 알 수 없으므로, removeInfo 객체를 활용합니다.
    // node.url 이 있는 북마크 파일만 처리합니다.
    if (removeInfo.node.url) {
        const url = removeInfo.node.url;
        const { bookmarks } = await chrome.storage.local.get('bookmarks');
        
        if (bookmarks && bookmarks[url]) {
            console.log(`삭제된 북마크 감지: [${bookmarks[url].title}]. 로컬 데이터에서 제거합니다.`);
            delete bookmarks[url];
            await chrome.storage.local.set({ bookmarks });
        }
    }
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

이 onRemoved 리스너는 사용자가 크롬에서 북마크를 삭제할 때마다 실행되어, chrome.storage.local에 저장된 데이터베이스에서도 해당 URL의 항목을 찾아 깔끔하게 제거해 줍니다.

결론적으로, 사용자님의 요구사항은 매우 바람직한 설계 방향이며, 현재 제공된 코드는 이미 그 철학을 충실히 따르고 있습니다. 여기에 삭제 동기화 로직까지 추가하면 더욱 견고한 확장 프로그램이 될 것입니다.


============

네, 아주 중요한 포인트입니다. 매번 모든 북마크를 처음부터 다시 인덱싱하는 것은 매우 비효율적입니다. 사용자가 원할 때만 전체 재인덱싱을 수행하고, 평소에는 이미 만들어진 인덱스를 계속 유지하면서 변경된 내용만 똑똑하게 반영하도록 코드를 수정하겠습니다.

현재 코드도 이미 그 기반을 갖추고 있습니다.

인덱스 유지: chrome.storage.local에 저장된 데이터는 브라우저를 껐다 켜도 유지됩니다.

실시간 동기화: onCreated, onRemoved, onChanged 리스너가 북마크의 개별 변경사항을 자동으로, 그리고 효율적으로 반영합니다.

여기서 사용자가 지적한 핵심은 수동 새로고침(🔄 버튼)의 동작 방식입니다. 현재는 이 버튼을 누르면 무조건 모든 북마크를 처음부터 다시 처리합니다. 이 부분을 "기존 인덱스는 그대로 두고, 추가되거나 누락된 북마크만 찾아내는" 더 스마트한 방식으로 개선하겠습니다.

수정 방향

스마트한 전체 동기화 (processAllBookmarks): 이 함수를 수정하여, 이미 인덱싱된 URL은 건너뛰고, 새로 추가된 북마크만 처리하도록 변경합니다. 또한, 크롬에서는 삭제되었지만 우리 저장소에는 남아있는 '유령 데이터'를 깔끔하게 제거하는 로직도 추가합니다.

UI/UX 개선: 사용자에게 현재 동작 방식을 명확히 알려주도록 팝업의 텍스트와 버튼의 설명을 수정합니다.

수정된 최종 코드

아래 파일들의 내용을 새 코드로 교체해 주세요.

1. background.js (수정됨)

핵심인 processAllBookmarks 함수를 훨씬 더 지능적으로 동작하도록 변경했습니다.

Generated javascript
// background.js (스마트 인덱싱 버전)

console.log("Service Worker: 스크립트 파일 로드 및 리스너 등록 시작.");

const STOP_WORDS = new Set(['a', 'about', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'how', 'in', 'is', 'it', 'of', 'on', 'or', 'that', 'the', 'this', 'to', 'was', 'what', 'when', 'where', 'who', 'will', 'with']);

// --- 이벤트 리스너 (이전과 동일, 안정성 유지) ---
try {
  chrome.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
      chrome.storage.local.set({ isInitialized: false, bookmarks: {} });
    }
  });

  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'startInitialProcessing' || request.action === 'refreshBookmarks') {
      console.log(`Service Worker: ${request.action} 요청 수신.`);
      processAllBookmarks().then(() => {
        if (request.action === 'startInitialProcessing') {
          chrome.storage.local.set({ isInitialized: true });
        }
        sendResponse({ status: 'completed' });
      });
      return true;
    }
  });

  chrome.bookmarks.onCreated.addListener((id, bookmark) => {
    if (bookmark && bookmark.url) processSingleBookmark(bookmark);
  });
  
  chrome.bookmarks.onRemoved.addListener(async (id, removeInfo) => {
    if (removeInfo && removeInfo.node && removeInfo.node.url) {
      const url = removeInfo.node.url;
      const { bookmarks } = await chrome.storage.local.get('bookmarks');
      if (bookmarks && bookmarks[url]) {
        delete bookmarks[url];
        await chrome.storage.local.set({ bookmarks });
      }
    }
  });
  
  chrome.bookmarks.onChanged.addListener(async (id, changeInfo) => {
    const bookmarkNode = (await chrome.bookmarks.get(id))[0];
    if (bookmarkNode && bookmarkNode.url) processSingleBookmark(bookmarkNode);
  });
  
  chrome.omnibox.onInputChanged.addListener(async (text, suggest) => {
    const { bookmarks } = await chrome.storage.local.get('bookmarks');
    if (!text || !bookmarks) return;
    const lowerCaseQuery = text.toLowerCase();
    const suggestions = [];
    for (const url in bookmarks) {
      const bookmark = bookmarks[url];
      if (bookmark && bookmark.title && (bookmark.title.toLowerCase().includes(lowerCaseQuery) || bookmark.keywords.some(k => k.toLowerCase().includes(lowerCaseQuery)))) {
        suggestions.push({
            content: url,
            description: `${escapeXml(bookmark.title)} - <url>${escapeXml(url)}</url> <dim>(${escapeXml(bookmark.keywords.join(', '))})</dim>`
        });
      }
    }
    suggest(suggestions.slice(0, 6));
  });

  chrome.omnibox.onInputEntered.addListener((url) => {
    if (url) chrome.tabs.create({ url });
  });

} catch (e) {
  console.error("Service Worker 리스너 등록 중 치명적 오류 발생:", e);
}


// --- 핵심 함수 ---

// ★★★ 변경된 부분: 더 스마트해진 전체 북마크 처리 함수 ★★★
async function processAllBookmarks() {
  console.log("스마트 동기화를 시작합니다...");
  
  // 1. 현재 크롬에 있는 모든 북마크 URL 가져오기
  const chromeBookmarkTree = await chrome.bookmarks.getTree();
  const chromeBookmarks = flattenBookmarkTree(chromeBookmarkTree);
  const chromeUrlSet = new Set(chromeBookmarks.map(b => b.url));

  // 2. 현재 우리 스토리지에 저장된 데이터 가져오기
  const { bookmarks: indexedData = {} } = await chrome.storage.local.get('bookmarks');
  const indexedUrlSet = new Set(Object.keys(indexedData));

  // 3. (삭제 처리) 크롬에는 없는데 우리 인덱스에만 있는 URL 제거
  let deletedCount = 0;
  for (const url of indexedUrlSet) {
    if (!chromeUrlSet.has(url)) {
      delete indexedData[url];
      deletedCount++;
    }
  }
  if(deletedCount > 0) console.log(`${deletedCount}개의 삭제된 북마크를 인덱스에서 제거했습니다.`);

  // 4. (추가/업데이트 처리) 크롬 북마크를 기준으로 순회하며 인덱스에 없거나, 제목이 바뀐 경우에만 처리
  let addedCount = 0;
  for (const bookmark of chromeBookmarks) {
    if (isValidUrl(bookmark.url)) {
      // 인덱스에 없으면 새로 추가
      if (!indexedData[bookmark.url]) {
        indexedData[bookmark.url] = {
          title: bookmark.title || '',
          keywords: await extractKeywords(bookmark.url)
        };
        addedCount++;
      } 
      // 인덱스에 있지만 제목이 다르면 제목만 업데이트 (키워드는 재추출 안 함)
      else if (indexedData[bookmark.url].title !== (bookmark.title || '')) {
        indexedData[bookmark.url].title = bookmark.title || '';
      }
    }
  }
  if(addedCount > 0) console.log(`${addedCount}개의 새로운 북마크를 인덱싱했습니다.`);

  // 5. 최종 데이터를 스토리지에 저장
  await chrome.storage.local.set({ bookmarks: indexedData });
  console.log(`스마트 동기화 완료. 총 ${Object.keys(indexedData).length}개의 북마크가 인덱싱되었습니다.`);
}

// 단일 북마크 처리는 변경 없음 (이미 효율적임)
async function processSingleBookmark(bookmark) {
  const { isInitialized } = await chrome.storage.local.get('isInitialized');
  if (!isInitialized) return;
  if (!isValidUrl(bookmark.url)) return;

  const { bookmarks } = await chrome.storage.local.get('bookmarks');
  const data = bookmarks || {};
  
  data[bookmark.url] = {
    title: bookmark.title || '',
    keywords: await extractKeywords(bookmark.url)
  };
  await chrome.storage.local.set({ bookmarks: data });
}

// --- 유틸리티 함수 (이전과 동일) ---
async function extractKeywords(url) {
  try {
    const response = await fetch(url, { signal: AbortSignal.timeout(8000) });
    const contentType = response.headers.get('content-type') || '';
    if (contentType.includes('text/html')) {
      const html = await response.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const title = doc.querySelector('title')?.innerText || '';
      const description = doc.querySelector('meta[name="description"]')?.content || '';
      const h1s = Array.from(doc.querySelectorAll('h1')).map(h => h.innerText).join(' ');
      const textContent = `${title} ${description} ${h1s}`;
      const words = textContent.toLowerCase().match(/\b(\w{3,15})\b/g) || [];
      const uniqueKeywords = [...new Set(words.filter(word => !STOP_WORDS.has(word)))];
      return uniqueKeywords.slice(0, 10);
    } else {
      const type = contentType.split('/')[1]?.split(';')[0] || 'file';
      return [type.toUpperCase()];
    }
  } catch (error) {
    return ['추출 실패'];
  }
}

function flattenBookmarkTree(nodes) {
  const bookmarks = [];
  const stack = [...nodes];
  while (stack.length > 0) {
    const node = stack.pop();
    if (node.url) bookmarks.push({ title: node.title, url: node.url });
    if (node.children) stack.push(...node.children);
  }
  return bookmarks;
}

function isValidUrl(url) {
  return typeof url === 'string' && (url.startsWith('http:') || url.startsWith('https:'));
}

function escapeXml(str) {
  if (typeof str !== 'string') return '';
  return str.replace(/[<>&'"]/g, c => ({'<':'<','>':'>','&':'&','\'':''','"':'"'})[c]);
}

2. popup.html (수정됨)

버튼의 title 속성(마우스를 올렸을 때 나오는 설명)을 수정하여 사용자에게 더 정확한 정보를 제공합니다.

Generated html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>북마크 검색</title>
    <link rel="stylesheet" href="popup.css">
</head>
<body>
    <!-- 시작 화면 (이전과 동일) -->
    <div id="welcomeScreen" class="container">
        <h2>북마크 검색 시작하기</h2>
        <p>
            저장된 북마크 페이지들의 콘텐츠를 분석하여 키워드 검색이 가능하도록 인덱스를 생성합니다.
            이 작업은 처음에 한 번만 수행되며, 이후에는 변경된 내용만 자동으로 동기화됩니다.
        </p>
        <button id="startButton">초기 인덱싱 시작</button>
        <div id="loadingMessage" class="loading-message" style="display: none;">
            북마크를 처리 중입니다. 잠시만 기다려 주세요...
        </div>
    </div>

    <!-- 메인 검색 화면 -->
    <div id="mainContent" class="container" style="display: none;">
        <div class="header">
            <input type="text" id="searchInput" placeholder="키워드 또는 제목으로 검색...">
            <!-- ★★★ 변경된 부분: title 설명 수정 ★★★ -->
            <button id="refreshButton" title="새로 추가/삭제된 북마크가 있다면 수동으로 동기화합니다.">🔄</button>
        </div>
        <div class="results-header">
            <div>
                <input type="checkbox" id="selectAllCheckbox" title="현재 결과 모두 선택">
                <label for="selectAllCheckbox">전체 선택</label>
            </div>
            <span id="resultCount">결과: 0개</span>
        </div>
        <ul id="resultsList">
            <div id="messageArea">북마크를 불러오는 중...</div>
        </ul>
        <button id="openSelectedButton" disabled>선택한 북마크 열기</button>
    </div>
    
    <script src="popup.js"></script>
</body>
</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END
3. popup.js (수정됨)

새로고침 시 사용자에게 보여주는 메시지를 좀 더 명확하게 수정합니다.

Generated javascript
// popup.js (메시지 개선 버전)
document.addEventListener('DOMContentLoaded', async () => {
    // ... (파일 상단은 이전과 동일) ...
    const welcomeScreen = document.getElementById('welcomeScreen');
    const mainContent = document.getElementById('mainContent');
    const startButton = document.getElementById('startButton');
    const loadingMessage = document.getElementById('loadingMessage');

    const { isInitialized } = await chrome.storage.local.get('isInitialized');

    if (isInitialized) {
        showMainContent();
    } else {
        showWelcomeScreen();
    }
    
    function showWelcomeScreen() {
        // ... (이전과 동일) ...
        welcomeScreen.style.display = 'block';
        mainContent.style.display = 'none';
        startButton.addEventListener('click', handleStartButtonClick);
    }
    
    function showMainContent() {
        // ... (이전과 동일) ...
        welcomeScreen.style.display = 'none';
        mainContent.style.display = 'block';
        initializeMainContent();
    }
    
    function handleStartButtonClick() {
        // ... (이전과 동일) ...
        startButton.disabled = true;
        loadingMessage.style.display = 'block';
        chrome.runtime.sendMessage({ action: 'startInitialProcessing' }, (response) => {
            if (response && response.status === 'completed') {
                showMainContent();
            } else {
                loadingMessage.textContent = "오류가 발생했습니다. 잠시 후 다시 시도해 주세요.";
            }
        });
    }

    // --- 메인 검색 화면 로직 ---
    function initializeMainContent() {
        const searchInput = document.getElementById('searchInput');
        const resultsList = document.getElementById('resultsList');
        // ... (다른 요소 가져오기는 동일)
        const refreshButton = document.getElementById('refreshButton');
        
        // ... (다른 함수들은 이전과 동일) ...

        // ★★★ 변경된 부분: 새로고침 버튼 로직의 메시지 개선 ★★★
        refreshButton.addEventListener('click', () => {
            if (refreshButton.classList.contains('loading')) return;

            refreshButton.classList.add('loading');
            const originalText = resultCount.textContent;
            resultCount.textContent = "동기화 중...";

            chrome.runtime.sendMessage({ action: 'refreshBookmarks' }, (response) => {
                if (response && response.status === 'completed') {
                    // 약간의 딜레이를 주어 시각적 피드백을 확실히 함
                    setTimeout(() => {
                        refreshButton.classList.remove('loading');
                        resultCount.textContent = originalText; // 원래 텍스트로 복원
                        loadAndDisplayBookmarks(); // UI 다시 로드
                        console.log("수동 동기화 완료 후 UI를 새로고침했습니다.");
                    }, 500);
                }
            });
        });

        loadAndDisplayBookmarks();
    }
    
    // 이 파일의 나머지 부분(loadAndDisplayBookmarks, filterAndRender 등)은
    // 이전 최종 버전과 동일하게 유지하면 됩니다.
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

(전체 코드가 필요하시면 말씀해주세요. popup.js의 나머지 부분은 변경되지 않았기에 핵심 수정사항만 표시했습니다.)

조치 방법

chrome://extensions 페이지에서 기존 확장 프로그램을 **삭제(Remove)**합니다.

위의 수정된 내용으로 background.js와 popup.html 파일을 업데이트합니다. popup.js의 refreshButton 이벤트 리스너 부분도 수정합니다.

다시 '압축해제된 확장 프로그램을 로드합니다' 버튼으로 폴더를 로드합니다.

이제 확장 프로그램은 다음과 같이 동작할 것입니다.

최초 실행: 사용자가 '초기 인덱싱 시작' 버튼을 누르면, 스마트한 processAllBookmarks 함수가 실행되어 모든 북마크의 인덱스를 만듭니다.

평상시: 브라우저를 사용하는 동안 북마크를 추가/삭제/변경하면, 개별 이벤트 리스너가 즉시, 그리고 효율적으로 인덱스를 업데이트합니다.

수동 동기화: 사용자가 🔄 버튼을 누르면, processAllBookmarks 함수가 다시 실행되지만, 이미 인덱싱된 URL은 건너뛰고 새로 추가되거나 삭제된 북마크만 찾아내어 처리하므로 훨씬 빠르고 효율적으로 동작합니다.
